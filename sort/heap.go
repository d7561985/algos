package sort

/*
implementation heap sort algorithm (Пирамидальная сортировка)
O(n * log n)

buildHeap: O(n)

1 &[16 11 15 9 10 13 14 8 2 1 5 12 6 3 7 4]
2 &[4 11 15 9 10 13 14 8 2 1 5 12 6 3 7 16]
1 &[15 11 14 9 10 13 7 8 2 1 5 12 6 3 4 16]
2 &[4 11 14 9 10 13 7 8 2 1 5 12 6 3 15 16]
1 &[14 11 13 9 10 12 7 8 2 1 5 4 6 3 15 16]
2 &[3 11 13 9 10 12 7 8 2 1 5 4 6 14 15 16]
1 &[13 11 12 9 10 6 7 8 2 1 5 4 3 14 15 16]
2 &[3 11 12 9 10 6 7 8 2 1 5 4 13 14 15 16]
1 &[12 11 7 9 10 6 3 8 2 1 5 4 13 14 15 16]
2 &[4 11 7 9 10 6 3 8 2 1 5 12 13 14 15 16]
1 &[11 10 7 9 5 6 3 8 2 1 4 12 13 14 15 16]
2 &[4 10 7 9 5 6 3 8 2 1 11 12 13 14 15 16]
1 &[10 9 7 8 5 6 3 4 2 1 11 12 13 14 15 16]
2 &[1 9 7 8 5 6 3 4 2 10 11 12 13 14 15 16]
1 &[9 8 7 4 5 6 3 1 2 10 11 12 13 14 15 16]
2 &[2 8 7 4 5 6 3 1 9 10 11 12 13 14 15 16]
1 &[8 5 7 4 2 6 3 1 9 10 11 12 13 14 15 16]
2 &[1 5 7 4 2 6 3 8 9 10 11 12 13 14 15 16]
1 &[7 5 6 4 2 1 3 8 9 10 11 12 13 14 15 16]
2 &[3 5 6 4 2 1 7 8 9 10 11 12 13 14 15 16]
1 &[6 5 3 4 2 1 7 8 9 10 11 12 13 14 15 16]
2 &[1 5 3 4 2 6 7 8 9 10 11 12 13 14 15 16]
1 &[5 4 3 1 2 6 7 8 9 10 11 12 13 14 15 16]
2 &[2 4 3 1 5 6 7 8 9 10 11 12 13 14 15 16]
1 &[4 2 3 1 5 6 7 8 9 10 11 12 13 14 15 16]
2 &[1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16]
1 &[3 2 1 4 5 6 7 8 9 10 11 12 13 14 15 16]
2 &[1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16]
1 &[2 1 3 4 5 6 7 8 9 10 11 12 13 14 15 16]
2 &[1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16]
[1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16]
*/

type Heap struct {
}

func (h *Heap) Sort(in *[]int) {
	h.buildHeap(in)

	for i := len(*in) - 1; i > 0; i-- {
		//fmt.Println("1", in)
		(*in)[0], (*in)[i] = (*in)[i], (*in)[0]
		//fmt.Println("2", in)
		h.heapify(in, 0, i)
	}
}

func (h *Heap) buildHeap(in *[]int) {
	for i := len(*in)/2 - 1; i >= 0; i-- {
		h.heapify(in, i, len(*in))
	}
}

func (h *Heap) heapify(_in *[]int, idx, max int) {
	largest := idx
	left := 2*idx + 1
	right := 2*idx + 2
	in := *_in

	if left < max && in[left] > in[idx] {
		largest = left
	}

	if right < max && in[right] > in[largest] {
		largest = right
	}

	if largest != idx {
		(*_in)[largest], (*_in)[idx] = (*_in)[idx], (*_in)[largest]
		h.heapify(_in, largest, max)
	}
}
